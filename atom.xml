<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Questocat&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://questocat.com/"/>
  <updated>2018-05-30T09:11:07.171Z</updated>
  <id>http://questocat.com/</id>
  
  <author>
    <name>QUESTOCAT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Composer 扩展包开发</title>
    <link href="http://questocat.com//blog/2017/12/08/composer-extension-development.html"/>
    <id>http://questocat.com//blog/2017/12/08/composer-extension-development.html</id>
    <published>2017-12-07T16:00:00.000Z</published>
    <updated>2018-05-30T09:11:07.171Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>最近在开发一个比较独立的功能，因此打算使用 Composer 来实现模块化开发（该包是基于 Laravel 的扩展）。这里有个要求是，开发人员在本地开发完成某个模块后，能够快速地部署到测试环境，让测试人员进行测试。</p><h5 id="实现上面的要求需要满足"><a href="#实现上面的要求需要满足" class="headerlink" title="实现上面的要求需要满足"></a>实现上面的要求需要满足</h5><ul><li>本地开发时需要方便快速修改</li><li>测试时方便更新最新代码</li></ul><p>所以，整个开发的流程看起来是这样的：</p><p><img src="http://questocat.com/images/composer-extension-development.jpeg" alt="composer-private-repo"></p><p>其实，上面这种开发方式也可以适用于多人协作开发比较大的扩展包。</p><h5 id="如何加载扩展包"><a href="#如何加载扩展包" class="headerlink" title="如何加载扩展包"></a>如何加载扩展包</h5><p>在 Composer 中我们可以有两种方式加载扩展包目录，一种是使用 PSR-4 自动加载，另一种就是使用 Path 将扩展包以本地目录形式进行加载。<br>这里我主要说明怎样使用 Path 方式来进行加载，先说一下 Path 方式加载的工作原理，Composer 会帮我们创建一个文件夹链接，把 vendor/organization-name/my-package 文件夹链接到 packages/organization-name/my-package 下（packages 是我们在项目下创建的目录）。</p><p>首先在 composer.json 的 repositories 区块中添加一个项目源：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"repositories"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"path"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"packages/organization-name/my-package"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们在项目中添加包依赖：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"organization-name/my-package"</span>: <span class="string">"@dev"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="如何在测试环境中使用"><a href="#如何在测试环境中使用" class="headerlink" title="如何在测试环境中使用"></a>如何在测试环境中使用</h5><p>同样地，在 composer.json 的 repositories 区块中添加一个项目源（我们扩展包代码的地址）：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"repositories"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"vcs"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"git@10.1.2.215:/home/git/repo/composer_repo/my-package.git"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们在项目中添加包依赖：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"organization-name/my-package"</span>: <span class="string">"@dev"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，当我们在本地开发完成某个模块后，可以通过 GIT 方式将代码提交到代码库，然后测试服务器更新最近提交的代码，测试人员就可以测试最新的功能了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h5&gt;&lt;p&gt;最近在开发一个比较独立的功能，因此打算使用 Composer 来实现模块化开发（该包是基于 Laravel 的扩展）。这里有个要求是，开发人
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux BBR 实践</title>
    <link href="http://questocat.com//blog/2017/12/05/linux-bbr-practice.html"/>
    <id>http://questocat.com//blog/2017/12/05/linux-bbr-practice.html</id>
    <published>2017-12-04T16:00:00.000Z</published>
    <updated>2018-05-30T11:54:09.866Z</updated>
    
    <content type="html"><![CDATA[<p>BBR 的作用就是加速 TCP，尽可能的充分利用带宽；降低 buffer 占用率，从而降低延迟。</p><a id="more"></a><p>升级前下载速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[download] 100% of 171.28MiB <span class="keyword">in</span> 00:40</span><br><span class="line">[1]-  Done                    sudo youtube-dl https://www.youtube.com/watch?v=4SdcmxGC3Yc</span><br><span class="line">[2]+  Done                    list=PLo7mBDsRHu11Szh1t-CRqwliRGRA1JOZJ</span><br></pre></td></tr></table></figure><p>升级后下载速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[download] 100% of 171.28MiB <span class="keyword">in</span> 00:08</span><br><span class="line">[1]-  Done                    sudo youtube-dl https://www.youtube.com/watch?v=4SdcmxGC3Yc</span><br><span class="line">[2]+  Done                    list=PLo7mBDsRHu11Szh1t-CRqwliRGRA1JOZJ</span><br></pre></td></tr></table></figure><p>升级前的准备</p><p>系统内核要求：Linux kernel 4.9 及以上</p><p>检查系统内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>如果系统版本不满足要求，先升级内核：<br>在 内核下载地址 里找到你要用的内核，即 4.9+ 版本。 另外你要注意：<br>如果系统是 64 位，则下载 amd64 的 linux-image 中含有 generic 这个 deb 包；<br>如果系统是 32 位，则下载 i386 的 linux-image 中含有 generic 这个 deb 包 这里我使用的是 4.10 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10/linux-image-4.10.0-041000-generic_4.10.0-041000.201702191831_amd64.deb</span><br><span class="line">sudo dpkg -i linux-image-4.10.0-041000-generic_4.10.0-041000.201702191831_amd64.deb</span><br><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>安装（开启） BBR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.default_qdisc=fq"</span> &gt;&gt; /etc/sysctl.conf  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_congestion_control=bbr"</span> &gt;&gt; /etc/sysctl.conf  </span><br><span class="line">sysctl -p  <span class="comment"># 立即生效配置</span></span><br></pre></td></tr></table></figure><p>内核是否已开启 BBR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control  </span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>当前内核是否载入 tcp_bbr 模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10" target="_blank" rel="noopener">内核下载地址</a></li><li><a href="https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">开启TCP BBR拥塞控制算法</a></li><li><a href="https://www.zhihu.com/question/53559433" target="_blank" rel="noopener">Linux Kernel 4.9 中的 BBR 算法与之前的 TCP 拥塞控制相比有什么优势？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BBR 的作用就是加速 TCP，尽可能的充分利用带宽；降低 buffer 占用率，从而降低延迟。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
